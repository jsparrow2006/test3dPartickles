{"addforce.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_velocityTexture;\n\nuniform vec3 u_mouseVelocity;\n\nuniform vec3 u_gridResolution;\nuniform vec3 u_gridSize;\n\nuniform vec3 u_mouseRayOrigin;\nuniform vec3 u_mouseRayDirection;\n\nuniform float u_timeStep;\n\nfloat kernel (vec3 position, float radius) {\n    vec3 worldPosition = (position / u_gridResolution) * u_gridSize;\n\n    float distanceToMouseRay = length(cross(u_mouseRayDirection, worldPosition - u_mouseRayOrigin));\n\n    float normalizedDistance = max(0.0, distanceToMouseRay / radius);\n    return smoothstep(1.0, 0.9, normalizedDistance);\n}\n\nvoid main () {\n    vec3 velocity = texture2D(u_velocityTexture, v_coordinates).rgb;\n\n    vec3 newVelocity = velocity + vec3(0.0, -40.0 * u_timeStep, 0.0); //add gravity\n\n    vec3 cellIndex = floor(get3DFragCoord(u_gridResolution + 1.0));\n    vec3 xPosition = vec3(cellIndex.x, cellIndex.y + 0.5, cellIndex.z + 0.5);\n    vec3 yPosition = vec3(cellIndex.x + 0.5, cellIndex.y, cellIndex.z + 0.5);\n    vec3 zPosition = vec3(cellIndex.x + 0.5, cellIndex.y + 0.5, cellIndex.z);\n\n    float mouseRadius = 5.0;\n    vec3 kernelValues = vec3(kernel(xPosition, mouseRadius), kernel(yPosition, mouseRadius), kernel(zPosition, mouseRadius));\n\n    newVelocity += u_mouseVelocity * kernelValues * 3.0 * smoothstep(0.0, 1.0 / 200.0, u_timeStep);\n\n    gl_FragColor = vec4(newVelocity * 1.0, 0.0);\n}\n","advect.frag":"//advects particle positions with second order runge kutta\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_randomsTexture;\n\nuniform sampler2D u_velocityGrid;\n\nuniform vec3 u_gridResolution;\nuniform vec3 u_gridSize;\n\nuniform float u_timeStep;\n\nuniform float u_frameNumber;\n\nuniform vec2 u_particlesResolution;\n\nfloat sampleXVelocity (vec3 position) {\n    vec3 cellIndex = vec3(position.x, position.y - 0.5, position.z - 0.5);\n    return texture3D(u_velocityGrid, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).x;\n}\n\nfloat sampleYVelocity (vec3 position) {\n    vec3 cellIndex = vec3(position.x - 0.5, position.y, position.z - 0.5);\n    return texture3D(u_velocityGrid, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).y;\n}\n\nfloat sampleZVelocity (vec3 position) {\n    vec3 cellIndex = vec3(position.x - 0.5, position.y - 0.5, position.z);\n    return texture3D(u_velocityGrid, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).z;\n}\n\nvec3 sampleVelocity (vec3 position) {\n    vec3 gridPosition = (position / u_gridSize) * u_gridResolution;\n    return vec3(sampleXVelocity(gridPosition), sampleYVelocity(gridPosition), sampleZVelocity(gridPosition));\n}\n\nvoid main () {\n    vec3 position = texture2D(u_positionsTexture, v_coordinates).rgb;\n    vec3 randomDirection = texture2D(u_randomsTexture, fract(v_coordinates + u_frameNumber / u_particlesResolution)).rgb;\n\n    vec3 velocity = sampleVelocity(position);\n\n    vec3 halfwayPosition = position + velocity * u_timeStep * 0.5;\n    vec3 halfwayVelocity = sampleVelocity(halfwayPosition);\n\n    vec3 step = halfwayVelocity * u_timeStep;\n\n    step += 0.05 * randomDirection * length(velocity) * u_timeStep;\n\n    //step = clamp(step, -vec3(1.0), vec3(1.0)); //enforce CFL condition\n\n    vec3 newPosition = position + step;\n\n    newPosition = clamp(newPosition, vec3(0.01), u_gridSize - 0.01);\n\n    gl_FragColor = vec4(newPosition, 0.0);\n}\n","background.frag":"precision highp float;\n\nvarying vec2 v_position;\n\nvoid main () {\n    vec3 backgroundColor = vec3(0.0) - length(v_position) * 0.1;\n    gl_FragColor = vec4(backgroundColor, 1.0);\n}\n","background.vert":"precision highp float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_position;\n\nvoid main () {\n    v_position = a_position;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n}\n","box.frag":"precision highp float;\n\nvarying vec3 v_cubePosition;\n\nuniform vec3 u_highlightSide;\nuniform vec3 u_highlightColor;\n\nvoid main () {\n    float epsilon = 0.001;\n    vec3 normalizedCubePosition = v_cubePosition * 2.0 - 1.0;\n\n    if (abs(normalizedCubePosition.x - u_highlightSide.x) < epsilon || abs(normalizedCubePosition.y - u_highlightSide.y) < epsilon || abs(normalizedCubePosition.z - u_highlightSide.z) < epsilon ) {\n        gl_FragColor = vec4(u_highlightColor, 1.0);\n    } else {\n        gl_FragColor = vec4(vec3(0.97), 1.0);\n    }\n}\n","box.vert":"precision highp float;\n\nattribute vec3 a_cubeVertexPosition;\n\nuniform vec3 u_translation;\nuniform vec3 u_scale;\n\nuniform mat4 u_viewMatrix;\nuniform mat4 u_projectionMatrix;\n\nvarying vec3 v_cubePosition;\n\nvoid main () {\n    v_cubePosition = a_cubeVertexPosition;\n\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(a_cubeVertexPosition * u_scale + u_translation, 1.0);\n}\n","boxwireframe.frag":"precision highp float;\n\nvoid main () {\n    gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n}\n","boxwireframe.vert":"precision highp float;\n\nattribute vec3 a_cubeVertexPosition;\n\nuniform vec3 u_translation;\nuniform vec3 u_scale;\n\nuniform mat4 u_viewMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main () {\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(a_cubeVertexPosition * u_scale + u_translation, 1.0);\n}\n","common.frag":"precision highp float;\n\nvec3 get3DFragCoord (vec3 resolution) {\n    return vec3(\n        mod(gl_FragCoord.x, resolution.x),\n        gl_FragCoord.y,\n        floor(gl_FragCoord.x / resolution.x) + 0.5);\n}\n\nvec4 texture3D(sampler2D texture, vec3 coordinates, vec3 resolution) {\n    vec3 fullCoordinates = coordinates * resolution; //in [(0, 0, 0), (resolution.x, resolution.y, resolutionz)] \n\n    fullCoordinates = clamp(fullCoordinates, vec3(0.5), vec3(resolution - 0.5));\n\n    //belowZIndex and aboveZIndex don't have the 0.5 offset\n    float belowZIndex = floor(fullCoordinates.z - 0.5);\n    float aboveZIndex = belowZIndex + 1.0; \n\n    //we interpolate the z\n    float fraction = fract(fullCoordinates.z - 0.5);\n\n    vec2 belowCoordinates = vec2(\n        belowZIndex * resolution.x + fullCoordinates.x,\n        fullCoordinates.y) / vec2(resolution.x * resolution.z, resolution.y);\n\n    vec2 aboveCoordinates = vec2(\n        aboveZIndex * resolution.x + fullCoordinates.x,\n        fullCoordinates.y) / vec2(resolution.x * resolution.z, resolution.y);\n\n    return mix(texture2D(texture, belowCoordinates), texture2D(texture, aboveCoordinates), fraction);\n}\n\nvec4 texture3DNearest(sampler2D texture, vec3 coordinates, vec3 resolution) { //clamps the z coordinate\n    vec3 fullCoordinates = coordinates * resolution; //in [(0, 0, 0), (resolution.x, resolution.y, resolutionz)] \n\n    fullCoordinates = clamp(fullCoordinates, vec3(0.5), vec3(resolution - 0.5));\n\n    float zIndex = floor(fullCoordinates.z);\n\n    vec2 textureCoordinates = vec2(\n        zIndex * resolution.x + fullCoordinates.x,\n        fullCoordinates.y) / vec2(resolution.x * resolution.z, resolution.y);\n\n    return texture2D(texture, textureCoordinates);\n}\n\n","composite.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_renderingTexture;\nuniform sampler2D u_occlusionTexture;\n\nuniform vec2 u_resolution;\nuniform float u_fov;\n\nuniform mat4 u_inverseViewMatrix;\n\nuniform sampler2D u_shadowDepthTexture;\nuniform vec2 u_shadowResolution;\nuniform mat4 u_lightProjectionViewMatrix;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\n\nfloat linearstep (float left, float right, float x) {\n    return clamp((x - left) / (right - left), 0.0, 1.0);\n}\n\nvec3 hsvToRGB(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main () {\n    vec4 data = texture2D(u_renderingTexture, v_coordinates);\n    float occlusion = texture2D(u_occlusionTexture, v_coordinates).r;\n\n    vec3 viewSpaceNormal = vec3(data.x, data.y, sqrt(1.0 - data.x * data.x - data.y * data.y));\n\n    float viewSpaceZ = data.a;\n    vec3 viewRay = vec3(\n        (v_coordinates.x * 2.0 - 1.0) * tan(u_fov / 2.0) * u_resolution.x / u_resolution.y,\n        (v_coordinates.y * 2.0 - 1.0) * tan(u_fov / 2.0),\n        -1.0);\n\n    vec3 viewSpacePosition = viewRay * -viewSpaceZ;\n    vec3 worldSpacePosition = vec3(u_inverseViewMatrix * vec4(viewSpacePosition, 1.0));\n\n    float speed = data.b;\n    // vec3 color = hsvToRGB(vec3(max(0.6 - speed * 0.0025, 0.52), 0.75, 1.0));\n\n    vec3 color;\n    vec3 COLORS[2];\n    COLORS[0] = vec3(0.464, 0.0, 1.0);\n    COLORS[1] = vec3(1.0, 0.31, 0.071);\n\n    if (data.b <= 15.0) {\n        color = u_color1;\n    } else {\n        color = u_color2;\n    }\n\n\n    vec4 lightSpacePosition = u_lightProjectionViewMatrix * vec4(worldSpacePosition, 1.0);\n    lightSpacePosition /= lightSpacePosition.w;\n    lightSpacePosition *= 0.5;\n    lightSpacePosition += 0.5;\n    vec2 lightSpaceCoordinates = lightSpacePosition.xy;\n    \n    float shadow = 1.0;\n    const int PCF_WIDTH = 2;\n    const float PCF_NORMALIZATION = float(PCF_WIDTH * 2 + 1) * float(PCF_WIDTH * 2 + 1);\n\n    for (int xOffset = -PCF_WIDTH; xOffset <= PCF_WIDTH; ++xOffset) {\n        for (int yOffset = -PCF_WIDTH; yOffset <= PCF_WIDTH; ++yOffset) {\n            float shadowSample = texture2D(u_shadowDepthTexture, lightSpaceCoordinates + 5.0 * vec2(float(xOffset), float(yOffset)) / u_shadowResolution).r;\n            if (lightSpacePosition.z > shadowSample + 0.001) shadow -= 1.0 / PCF_NORMALIZATION;\n        }\n    }\n\n\n    float ambient = 1.0 - occlusion * 0.7;\n    float direct = 1.0 - (1.0 - shadow) * 0.8;\n\n    color *= ambient * direct;\n\n    if (speed >= 0.0) {\n        gl_FragColor = vec4(color, 1.0);\n    } else {\n        vec3 backgroundColor = vec3(0.1) - length(v_coordinates * 2.0 - 1.0) * 0.1;\n        gl_FragColor = vec4(backgroundColor, 1.0);\n    }\n\n    //gl_FragColor = vec4(texture2D(u_shadowDepthTexture, v_coordinates).rrr, 1.0);\n}\n","copy.frag":"precision highp float;\n\nuniform sampler2D u_texture;\n\nvarying vec2 v_coordinates;\n\nvoid main () {\n    gl_FragColor = texture2D(u_texture, v_coordinates);\n}\n","divergence.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_velocityTexture;\nuniform sampler2D u_markerTexture;\nuniform sampler2D u_weightTexture;\n\nuniform vec3 u_gridResolution;\n\nuniform float u_maxDensity;\n\nvoid main () {\n    vec3 cellIndex = floor(get3DFragCoord(u_gridResolution));\n\n    //divergence = 0 in air cells\n    float fluidCell = texture3DNearest(u_markerTexture, (cellIndex + 0.5) / u_gridResolution, u_gridResolution).x;\n    if (fluidCell == 0.0) discard;\n\n\n    float leftX = texture3DNearest(u_velocityTexture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).x;\n    float rightX = texture3DNearest(u_velocityTexture, (cellIndex + vec3(1.0, 0.0, 0.0) + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).x;\n\n    float bottomY = texture3DNearest(u_velocityTexture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).y;\n    float topY = texture3DNearest(u_velocityTexture, (cellIndex + vec3(0.0, 1.0, 0.0) + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).y;\n\n    float backZ = texture3DNearest(u_velocityTexture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).z;\n    float frontZ = texture3DNearest(u_velocityTexture, (cellIndex + vec3(0.0, 0.0, 1.0) + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).z;\n\n    float divergence = ((rightX - leftX) + (topY - bottomY) + (frontZ - backZ)) / 1.0;\n\n    float density = texture3DNearest(u_weightTexture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).a;\n    divergence -= max((density - u_maxDensity) * 1.0, 0.0); //volume conservation\n\n    gl_FragColor = vec4(divergence, 0.0, 0.0, 0.0);\n}\n","enforceboundaries.frag":"//sets the velocities at the boundary cells\n\nprecision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_velocityTexture;\n\nuniform vec3 u_gridResolution;\n\nvoid main () {\n    vec3 velocity = texture2D(u_velocityTexture, v_coordinates).rgb;\n    vec3 cellIndex = floor(get3DFragCoord(u_gridResolution + 1.0));\n\n    if (cellIndex.x < 0.5) {\n        velocity.x = 0.0;\n    }\n\n    if (cellIndex.x > u_gridResolution.x - 0.5) {\n        velocity.x = 0.0;\n    }\n\n    if (cellIndex.y < 0.5) {\n        velocity.y = 0.0;\n    }\n\n    if (cellIndex.y > u_gridResolution.y - 0.5) {\n        velocity.y = min(velocity.y, 0.0);\n    }\n\n    if (cellIndex.z < 0.5) {\n        velocity.z = 0.0;\n    }\n\n    if (cellIndex.z > u_gridResolution.z - 0.5) {\n        velocity.z = 0.0;\n    }\n\n    gl_FragColor = vec4(velocity, 0.0);\n}\n","extendvelocity.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform vec2 u_gridResolution;\n\nuniform sampler2D u_velocityTexture;\nuniform sampler2D u_weightTexture;\n\nvoid main () {\n    vec2 velocity = texture2D(u_velocityTexture, v_coordinates).rg;\n\n    vec2 delta = 1.0 / (u_gridResolution + 1.0);\n\n    bool airX = texture2D(u_weightTexture, v_coordinates).x == 0.0;\n    bool airY = texture2D(u_weightTexture, v_coordinates).y == 0.0;\n\n    float closestXDistance = 100000.0;\n    float closestYDistance = 100000.0;\n\n    if (airX || airY) {\n        const int SEARCH_WIDTH = 1;\n        for (int y = -SEARCH_WIDTH; y <= SEARCH_WIDTH; ++y) {\n            for (int x = -SEARCH_WIDTH; x <= SEARCH_WIDTH; ++x) {\n                if (x != 0 && y != 0) {\n                    vec2 coordinates = v_coordinates + vec2(float(x), float(y)) * delta;\n                    float dist = float(x) * float(x) + float(y) * float(y);\n\n                    if (texture2D(u_weightTexture, coordinates).x > 0.0 && dist < closestXDistance && airX) {\n                        closestXDistance = dist;\n                        velocity.x = texture2D(u_velocityTexture, coordinates).r;\n                    }\n\n                    if (texture2D(u_weightTexture, coordinates).y > 0.0 && dist < closestYDistance && airY) {\n                        closestYDistance = dist;\n                        velocity.y = texture2D(u_velocityTexture, coordinates).g;\n                    }\n\n                }\n            }\n        }\n\n    }\n\n    gl_FragColor = vec4(velocity, 0.0, 0.0);\n}\n","fullscreen.vert":"precision highp float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_coordinates;\n\nvoid main () {\n    v_coordinates = a_position * 0.5 + 0.5;\n\n    gl_Position = vec4(a_position, 0.0, 1.0);\n}\n","fxaa.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_input;\n\nuniform vec2 u_resolution;\n\nconst float FXAA_SPAN_MAX = 8.0;\nconst float FXAA_REDUCE_MUL = 1.0 / 8.0;\nconst float FXAA_REDUCE_MIN = 1.0 / 128.0;\n \nvoid main () {\n    vec2 delta = 1.0 / u_resolution;\n\n    vec3 rgbNW = texture2D(u_input, v_coordinates + vec2(-1.0, -1.0) * delta).rgb;\n    vec3 rgbNE = texture2D(u_input, v_coordinates + vec2(1.0, -1.0) * delta).rgb;\n    vec3 rgbSW = texture2D(u_input, v_coordinates + vec2(-1.0, 1.0) * delta).rgb;\n    vec3 rgbSE = texture2D(u_input, v_coordinates + vec2(1.0, 1.0) * delta).rgb;\n    vec3 rgbM = texture2D(u_input, v_coordinates).rgb;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(\n        -((lumaNW + lumaNE) - (lumaSW + lumaSE)),\n        ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) * delta.xy;\n\n    vec3 rgbA = 0.5 * (texture2D(u_input, v_coordinates.xy + dir * (1.0 / 3.0 - 0.5)).xyz + texture2D(u_input, v_coordinates.xy + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(u_input, v_coordinates.xy + dir * -0.5).xyz + texture2D(u_input, v_coordinates.xy + dir * 0.5).xyz);\n    float lumaB = dot(rgbB, luma);\n    if (lumaB < lumaMin || lumaB > lumaMax) {\n        gl_FragColor = vec4(rgbA, 1.0);\n    } else {\n        gl_FragColor = vec4(rgbB, 1.0);\n    }\n}\n","grid.frag":"precision highp float;\n\nvoid main () {\n    gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0);\n}\n","grid.vert":"precision highp float;\n\nattribute vec3 a_vertexPosition;\n\nuniform vec3 u_translation;\n\nuniform mat4 u_viewMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main () {\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(u_translation + a_vertexPosition, 1.0);\n}\n","jacobi.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform vec3 u_gridResolution;\n\nuniform sampler2D u_pressureTexture;\nuniform sampler2D u_divergenceTexture;\nuniform sampler2D u_markerTexture;\n\nvoid main () {\n    vec3 centerCoords = get3DFragCoord(u_gridResolution) / u_gridResolution;\n\n    //pressure = 0 in air cells\n    float fluidCell = texture3DNearest(u_markerTexture, centerCoords, u_gridResolution).x;\n    if (fluidCell == 0.0) discard; //if this is an air cell\n\n    vec3 delta = 1.0 / u_gridResolution;\n\n    float divergenceCenter = texture3DNearest(u_divergenceTexture, centerCoords, u_gridResolution).r;\n\n    float left = texture3DNearest(u_pressureTexture, centerCoords + vec3(-delta.x, 0.0, 0.0), u_gridResolution).r;\n    float right = texture3DNearest(u_pressureTexture, centerCoords + vec3(delta.x, 0.0, 0.0), u_gridResolution).r;\n    float bottom = texture3DNearest(u_pressureTexture, centerCoords + vec3(0.0, -delta.y, 0.0), u_gridResolution).r;\n    float top = texture3DNearest(u_pressureTexture, centerCoords + vec3(0.0, delta.y, 0.0), u_gridResolution).r;\n    float back = texture3DNearest(u_pressureTexture, centerCoords + vec3(0.0, 0.0, -delta.z), u_gridResolution).r;\n    float front = texture3DNearest(u_pressureTexture, centerCoords + vec3(0.0, 0.0, delta.z), u_gridResolution).r;\n\n    float newPressure = (left + right + bottom + top + back + front - divergenceCenter) / 6.0;\n\n\n    gl_FragColor = vec4(newPressure, 0.0, 0.0, 0.0);\n\n}\n","mark.frag":"precision highp float;\n\nvoid main () {\n    gl_FragColor = vec4(1.0);\n}\n","mark.vert":"//marks pixels with 1.0 if there's a particle there\n\nprecision highp float;\n\nattribute vec2 a_textureCoordinates;\n\nuniform sampler2D u_positionTexture;\n\nuniform vec3 u_gridResolution;\nuniform vec3 u_gridSize;\n\nvoid main () {\n    gl_PointSize = 1.0;\n\n    vec3 position = texture2D(u_positionTexture, a_textureCoordinates).rgb;\n    position = (position / u_gridSize) * u_gridResolution;\n    vec3 cellIndex = floor(position);\n\n    vec2 textureCoordinates = vec2(\n        cellIndex.z * u_gridResolution.x + cellIndex.x + 0.5,\n        cellIndex.y + 0.5) / vec2(u_gridResolution.x * u_gridResolution.z, u_gridResolution.y);\n\n    gl_Position = vec4(textureCoordinates * 2.0 - 1.0, 0.0, 1.0);\n}\n","normalizegrid.frag":"//this does the divide in the weighted sum\n\nprecision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_accumulatedVelocityTexture;\nuniform sampler2D u_weightTexture;\n\nvoid main () {\n    vec3 accumulatedVelocity = texture2D(u_accumulatedVelocityTexture, v_coordinates).rgb;\n    vec3 weight = texture2D(u_weightTexture, v_coordinates).rgb;\n\n    float xVelocity = 0.0;\n    if (weight.x > 0.0) {\n        xVelocity = accumulatedVelocity.x / weight.x;\n    }\n\n    float yVelocity = 0.0;\n    if (weight.y > 0.0) {\n        yVelocity = accumulatedVelocity.y / weight.y;\n    }\n\n    float zVelocity = 0.0;\n    if (weight.z > 0.0) {\n        zVelocity = accumulatedVelocity.z / weight.z;\n    }\n\n    gl_FragColor = vec4(xVelocity, yVelocity, zVelocity, 0.0);\n}\n","particle.frag":"precision highp float;\n\nvarying vec3 v_velocity;\n\nvoid main () {\n    gl_FragColor = vec4(v_velocity * 0.5 + 0.5, 1.0);\n\n    gl_FragColor = vec4(mix(vec3(0.0, 0.2, 0.9), vec3(1.0, 0.3, 0.2), length(v_velocity) * 0.1), 1.0);\n}\n","particle.vert":"precision highp float;\n\nattribute vec2 a_textureCoordinates; //the texture coordinates that this particle's info is stored at\n\nuniform sampler2D u_positionTexture;\nuniform sampler2D u_velocityTexture;\n\nuniform vec2 u_resolution;\n\nvarying vec3 v_velocity;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\n\nvoid main () {\n    vec3 position = texture2D(u_positionTexture, a_textureCoordinates).rgb;\n    vec3 velocity = texture2D(u_velocityTexture, a_textureCoordinates).rgb;\n    v_velocity = velocity;\n\n    gl_PointSize = 1.0;\n\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(position, 1.0);\n}\n","point.frag":"precision highp float;\n\nvoid main () {\n    gl_FragColor = vec4(vec3(0.6), 1.0);\n}\n","point.vert":"precision highp float;\n\nattribute vec3 a_position;\n\nuniform vec3 u_position;\n\nuniform mat3 u_rotation;\n\nuniform mat4 u_viewMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main () {\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(u_position + u_rotation * a_position * 0.2, 1.0);\n}\n","sphere.frag":"precision highp float;\n\nvarying vec3 v_viewSpacePosition;\nvarying vec3 v_viewSpaceNormal;\nvarying float v_speed;\n\nvoid main () {\n    gl_FragColor = vec4(v_viewSpaceNormal.x, v_viewSpaceNormal.y, v_speed, v_viewSpacePosition.z);\n}\n","sphere.vert":"precision highp float;\n\nattribute vec3 a_vertexPosition;\nattribute vec3 a_vertexNormal;\n\nattribute vec2 a_textureCoordinates;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\n\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_velocitiesTexture;\n\nuniform float u_sphereRadius;\n\nvarying vec3 v_viewSpacePosition;\nvarying vec3 v_viewSpaceNormal;\nvarying float v_speed;\n\nvoid main () {\n    vec3 spherePosition = texture2D(u_positionsTexture, a_textureCoordinates).rgb;\n\n    vec3 position = a_vertexPosition * u_sphereRadius + spherePosition;\n\n    v_viewSpacePosition = vec3(u_viewMatrix * vec4(position, 1.0));\n    v_viewSpaceNormal = vec3(u_viewMatrix * vec4(a_vertexNormal, 0.0));\n\n    gl_Position = u_projectionMatrix * vec4(v_viewSpacePosition, 1.0);\n\n    vec3 velocity = texture2D(u_velocitiesTexture, a_textureCoordinates).rgb;\n    v_speed = length(velocity);\n}\n","sphereao.frag":"precision highp float;\n\nuniform sampler2D u_renderingTexture;\n\nvarying vec3 v_viewSpaceSpherePosition;\nvarying float v_sphereRadius;\nvarying float v_extrudedSphereRadius;\n\nuniform vec2 u_resolution;\nuniform float u_fov;\n\nconst float PI = 3.14159265;\n\nvoid main () {\n    vec2 coordinates = gl_FragCoord.xy / u_resolution;\n    vec4 data = texture2D(u_renderingTexture, coordinates);\n\n    //reconstruct position\n\n    vec3 viewSpaceNormal = vec3(data.x, data.y, sqrt(1.0 - data.x * data.x - data.y * data.y));\n\n    float tanHalfFOV = tan(u_fov / 2.0);\n    float viewSpaceZ = data.a;\n    vec3 viewRay = vec3(\n        (coordinates.x * 2.0 - 1.0) * tanHalfFOV * u_resolution.x / u_resolution.y,\n        (coordinates.y * 2.0 - 1.0) * tanHalfFOV,\n        -1.0);\n\n    vec3 viewSpacePosition = viewRay * -viewSpaceZ;\n\n\n    vec3 di = v_viewSpaceSpherePosition - viewSpacePosition;\n    float l = length(di);\n\n    float nl = dot(viewSpaceNormal, di / l);\n    float h = l / v_sphereRadius;\n    float h2 = h * h;\n    float k2 = 1.0 - h2 * nl * nl;\n\n    float result = max(0.0, nl) / h2;\n\n    if (k2 > 0.0 && l > v_sphereRadius) {\n        result = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n        result = result / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n        result /= PI;\n\n        // result = pow( clamp(0.5*(nl*h+1.0)/h2,0.0,1.0), 1.5 ); //cheap approximation\n    }\n\n    gl_FragColor = vec4(result, 0.0, 0.0, 1.0);\n\n\n}\n","sphereao.vert":"precision highp float;\n\nattribute vec3 a_vertexPosition;\n\nattribute vec2 a_textureCoordinates;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\n\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_velocitiesTexture;\n\nuniform float u_sphereRadius;\n\nvarying vec3 v_viewSpaceSpherePosition;\nvarying float v_sphereRadius;\nvarying float v_extrudedSphereRadius;\n\nvoid main () {\n    vec3 spherePosition = texture2D(u_positionsTexture, a_textureCoordinates).rgb;\n    v_viewSpaceSpherePosition = vec3(u_viewMatrix * vec4(spherePosition, 1.0));\n\n    v_sphereRadius = u_sphereRadius;\n    v_extrudedSphereRadius = v_sphereRadius * 1.8;\n    \n    vec3 position = a_vertexPosition * v_extrudedSphereRadius + spherePosition;\n\n    gl_Position = u_projectionMatrix * u_viewMatrix * vec4(position, 1.0);\n}\n","spheredepth.frag":"precision highp float;\n\nvoid main () {\n    gl_FragColor = vec4(1.0);\n}\n","spheredepth.vert":"precision highp float;\n\nattribute vec3 a_vertexPosition;\nattribute vec3 a_vertexNormal;\n\nattribute vec2 a_textureCoordinates;\n\nuniform mat4 u_projectionViewMatrix;\n\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_velocitiesTexture;\n\nuniform float u_sphereRadius;\n\nvoid main () {\n    vec3 spherePosition = texture2D(u_positionsTexture, a_textureCoordinates).rgb;\n\n    vec3 position = a_vertexPosition * u_sphereRadius + spherePosition;\n\n    gl_Position = u_projectionViewMatrix * vec4(position, 1.0);\n}\n","subtract.frag":"precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform vec3 u_gridResolution;\n\nuniform sampler2D u_pressureTexture;\nuniform sampler2D u_velocityTexture;\nuniform sampler2D u_markerTexture;\n\nvoid main () {\n    vec3 cellIndex = floor(get3DFragCoord(u_gridResolution + 1.0));\n\n    float left = texture3DNearest(u_pressureTexture, (cellIndex + vec3(-1.0, 0.0, 0.0) + 0.5) / u_gridResolution, u_gridResolution).r;\n    float right = texture3DNearest(u_pressureTexture, (cellIndex + 0.5) / u_gridResolution, u_gridResolution).r;\n\n    float bottom = texture3DNearest(u_pressureTexture, (cellIndex + vec3(0.0, -1.0, 0.0) + 0.5) / u_gridResolution, u_gridResolution).r;\n    float top = texture3DNearest(u_pressureTexture, (cellIndex + 0.5) / u_gridResolution, u_gridResolution).r;\n\n    float back = texture3DNearest(u_pressureTexture, (cellIndex + vec3(0.0, 0.0, -1.0) + 0.5) / u_gridResolution, u_gridResolution).r;\n    float front = texture3DNearest(u_pressureTexture, (cellIndex + 0.5) / u_gridResolution, u_gridResolution).r;\n\n\n    //compute gradient of pressure\n    vec3 gradient = vec3(right - left, top - bottom, front - back) / 1.0;\n\n    vec3 currentVelocity = texture2D(u_velocityTexture, v_coordinates).rgb;\n\n    vec3 newVelocity = currentVelocity - gradient;\n\n    gl_FragColor = vec4(newVelocity, 0.0);\n}\n","transfertogrid.frag":"//two modes:\n//in one we accumulate (xWeight, yWeight, zWeight, centerWeight)\n//in the other we accumulate (xWeight * velocity.x, yWeight * velocity.y, zWeight * velocity.z, 0)\n\n//needs a division as a second step\n\nvarying vec3 v_position; //already in the grid coordinate system\nvarying vec3 v_velocity;\n\nuniform vec3 u_gridResolution;\n\nvarying float v_zIndex;\n\nuniform int u_accumulate; //when this is 0, we accumulate (xWeight, yWeight, 0, centerWeight), when 1 we accumulate (xWeight * velocity.x, yWeight * velocity.y, 0, 0)\n\nfloat h (float r) {\n    if (r >= 0.0 && r <= 1.0) {\n        return 1.0 - r;\n    } else if (r >= -1.0 && r <= 0.0) {\n        return 1.0 + r;\n    } else {\n        return 0.0;\n    }\n}\n\nfloat k (vec3 v) {\n    return h(v.x) * h(v.y) * h(v.z);\n}\n\nvoid main () {\n    vec3 cellIndex = floor(get3DFragCoord(u_gridResolution + 1.0));\n\n    if (cellIndex.z == v_zIndex) { //make sure we're in the right slice to prevent bleeding\n        //staggered grid position and therefor weight is different for x, y, z and scalar values\n        vec3 xPosition = vec3(cellIndex.x, cellIndex.y + 0.5, cellIndex.z + 0.5);\n        float xWeight = k(v_position - xPosition);\n\n        vec3 yPosition = vec3(cellIndex.x + 0.5, cellIndex.y, cellIndex.z + 0.5);\n        float yWeight = k(v_position - yPosition);\n\n        vec3 zPosition = vec3(cellIndex.x + 0.5, cellIndex.y + 0.5, cellIndex.z);\n        float zWeight = k(v_position - zPosition);\n\n        vec3 scalarPosition = vec3(cellIndex.x + 0.5, cellIndex.y + 0.5, cellIndex.z + 0.5);\n        float scalarWeight = k(v_position - scalarPosition);\n\n        if (u_accumulate == 0) {\n            gl_FragColor = vec4(xWeight, yWeight, zWeight, scalarWeight);\n        } else if (u_accumulate == 1) {\n            gl_FragColor = vec4(xWeight * v_velocity.x, yWeight * v_velocity.y, zWeight * v_velocity.z, 0.0);\n        }\n\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n","transfertogrid.vert":"//transfers particle velocities to the grid by splatting them using additive blending\n\nprecision highp float;\n\nattribute vec2 a_textureCoordinates;\n\nuniform sampler2D u_positionTexture;\nuniform sampler2D u_velocityTexture;\n\nuniform vec3 u_gridSize;\nuniform vec3 u_gridResolution;\n\nvarying vec3 v_position;\nvarying vec3 v_velocity;\n\nuniform float u_zOffset; //the offset for the z layer we're splatting into\nvarying float v_zIndex; //the z layer we're splatting into\n\nvoid main () {\n    gl_PointSize = 5.0; //TODO: i can probably compute this more accurately\n\n    vec3 position = texture2D(u_positionTexture, a_textureCoordinates).rgb;\n    position = (position / u_gridSize) * u_gridResolution;\n\n    vec3 velocity = texture2D(u_velocityTexture, a_textureCoordinates).rgb;\n    v_velocity = velocity;\n    v_position = position;\n\n    vec3 cellIndex = vec3(floor(position.xyz));\n    v_zIndex = cellIndex.z + u_zOffset; //offset into the right layer\n\n    vec2 textureCoordinates = vec2(\n        v_zIndex * (u_gridResolution.x + 1.0) + cellIndex.x + 0.5,\n        cellIndex.y + 0.5) / vec2((u_gridResolution.x + 1.0) * (u_gridResolution.z + 1.0), u_gridResolution.y + 1.0);\n\n    gl_Position = vec4(textureCoordinates * 2.0 - 1.0, 0.0, 1.0);\n}\n","transfertoparticles.frag":"//transfers velocities back to the particles \n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_particlePositionTexture;\nuniform sampler2D u_particleVelocityTexture;\n\nuniform sampler2D u_gridVelocityTexture;\nuniform sampler2D u_originalGridVelocityTexture; //the grid velocities before the update\n\nuniform vec3 u_gridResolution;\nuniform vec3 u_gridSize;\n\nuniform float u_flipness; //0 is full PIC, 1 is full FLIP\n\nfloat sampleXVelocity (sampler2D texture, vec3 position) {\n    vec3 cellIndex = vec3(position.x, position.y - 0.5, position.z - 0.5);\n    return texture3D(texture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).x;\n}\n\nfloat sampleYVelocity (sampler2D texture, vec3 position) {\n    vec3 cellIndex = vec3(position.x - 0.5, position.y, position.z - 0.5);\n    return texture3D(texture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).y;\n}\n\nfloat sampleZVelocity (sampler2D texture, vec3 position) {\n    vec3 cellIndex = vec3(position.x - 0.5, position.y - 0.5, position.z);\n    return texture3D(texture, (cellIndex + 0.5) / (u_gridResolution + 1.0), u_gridResolution + 1.0).z;\n}\n\nvec3 sampleVelocity (sampler2D texture, vec3 position) {\n    return vec3(sampleXVelocity(texture, position), sampleYVelocity(texture, position), sampleZVelocity(texture, position));\n}\n\nvoid main () {\n    vec3 particlePosition = texture2D(u_particlePositionTexture, v_coordinates).rgb;\n    particlePosition = (particlePosition / u_gridSize) * u_gridResolution;\n\n    vec3 particleVelocity = texture2D(u_particleVelocityTexture, v_coordinates).rgb;\n\n    vec3 currentVelocity = sampleVelocity(u_gridVelocityTexture, particlePosition);\n    vec3 originalVelocity = sampleVelocity(u_originalGridVelocityTexture, particlePosition);\n\n    vec3 velocityChange = currentVelocity - originalVelocity;\n\n    vec3 flipVelocity = particleVelocity + velocityChange;\n    vec3 picVelocity = currentVelocity;\n\n    gl_FragColor = vec4(mix(picVelocity, flipVelocity, u_flipness),  0.0);\n}\n"}